{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wind Farm Project Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Publish this to Github Pages mkdocs gh-deploy will publish whatever the branch you are currently working on. It will probably be cool to have a GitHub action. Github Repository The link to the Github Repository can be found here . Github Project The link to the Github SCRUM Project can be found here .","title":"Wind Farm Project"},{"location":"#wind-farm-project","text":"","title":"Wind Farm Project"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#publish-this-to-github-pages","text":"mkdocs gh-deploy will publish whatever the branch you are currently working on. It will probably be cool to have a GitHub action.","title":"Publish this to Github Pages"},{"location":"#github-repository","text":"The link to the Github Repository can be found here .","title":"Github Repository"},{"location":"#github-project","text":"The link to the Github SCRUM Project can be found here .","title":"Github Project"},{"location":"mqtt/","text":"MQTT Broker First analysis Components NodeMCU module I2C bus MCP23017 Segment LED bar Flux","title":"MQTT Broker"},{"location":"mqtt/#mqtt-broker","text":"","title":"MQTT Broker"},{"location":"mqtt/#first-analysis","text":"","title":"First analysis"},{"location":"mqtt/#components","text":"NodeMCU module I2C bus MCP23017 Segment LED bar","title":"Components"},{"location":"mqtt/#flux","text":"","title":"Flux"},{"location":"Supervision-Station/Supervision-Station/","text":"Supervision In the image below is shown the prototype proposal of the Supervision station . Requirements The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker. User story Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station. ChibiOS In order to find more information of ChibiOS, go here .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#supervision","text":"In the image below is shown the prototype proposal of the Supervision station .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#requirements","text":"The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker.","title":"Requirements"},{"location":"Supervision-Station/Supervision-Station/#user-story","text":"Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station.","title":"User story"},{"location":"Supervision-Station/Supervision-Station/#chibios","text":"In order to find more information of ChibiOS, go here .","title":"ChibiOS"},{"location":"Supervision-Station/arduino/","text":"Arduino The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system. I2C Protocol for RPi B connection /* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: }","title":"Arduino"},{"location":"Supervision-Station/arduino/#arduino","text":"The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system.","title":"Arduino"},{"location":"Supervision-Station/arduino/#i2c-protocol-for-rpi-b-connection","text":"/* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: }","title":"I2C Protocol for RPi B connection"},{"location":"Supervision-Station/chibios/","text":"ChibiOS Introduction Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling How works? Requirements Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Demos The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img . LCD Screen For LCD Screen, there is an example of that: #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; } Arduino I2C #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; }","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#chibios","text":"","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#introduction","text":"Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling","title":"Introduction"},{"location":"Supervision-Station/chibios/#how-works","text":"","title":"How works?"},{"location":"Supervision-Station/chibios/#requirements","text":"Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.","title":"Requirements"},{"location":"Supervision-Station/chibios/#demos","text":"The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img .","title":"Demos"},{"location":"Supervision-Station/chibios/#lcd-screen","text":"For LCD Screen, there is an example of that: #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; }","title":"LCD Screen"},{"location":"Supervision-Station/chibios/#arduino-i2c","text":"#include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; }","title":"Arduino I2C"},{"location":"dataproducer-1/dataproducer-1/","text":"Dataproducer 1 Components Temperature and humidity sensor LCD screen ESP-01 Flux","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#dataproducer-1","text":"","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#components","text":"Temperature and humidity sensor LCD screen ESP-01","title":"Components"},{"location":"dataproducer-1/dataproducer-1/#flux","text":"","title":"Flux"},{"location":"dataproducer-1/dht11/","text":"Humidity Sensor DH11 How it works How to connect to ESP-01 How to program it The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#humidity-sensor-dh11","text":"","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#how-it-works","text":"","title":"How it works"},{"location":"dataproducer-1/dht11/#how-to-connect-to-esp-01","text":"","title":"How to connect to ESP-01"},{"location":"dataproducer-1/dht11/#how-to-program-it","text":"The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"How to program it"},{"location":"dataproducer-1/graphical-lcd-backpack/","text":"Graphical LCD Backpack This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer. Connexions Example #include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#graphical-lcd-backpack","text":"This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer.","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#connexions","text":"","title":"Connexions"},{"location":"dataproducer-1/graphical-lcd-backpack/#example","text":"#include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Example"},{"location":"dataproducer-2/accelerometer/","text":"Accelerometer In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example. Instalation To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor. Initialization Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width } Example #include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#accelerometer","text":"In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example.","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#instalation","text":"To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor.","title":"Instalation"},{"location":"dataproducer-2/accelerometer/#initialization","text":"Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width }","title":"Initialization"},{"location":"dataproducer-2/accelerometer/#example","text":"#include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Example"},{"location":"dataproducer-2/dataproducer-2/","text":"Data producer 2 Components ESP-01 I2C bus Accelerotmeter LCD display Flux","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#data-producer-2","text":"","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#components","text":"ESP-01 I2C bus Accelerotmeter LCD display","title":"Components"},{"location":"dataproducer-2/dataproducer-2/#flux","text":"","title":"Flux"},{"location":"dataproducer-2/liquidcrystali2c/","text":"Liquid Crystal Display connected with i2c bus In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it. Instalation You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE. Example #include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); }","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#liquid-crystal-display-connected-with-i2c-bus","text":"In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it.","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#instalation","text":"You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE.","title":"Instalation"},{"location":"dataproducer-2/liquidcrystali2c/#example","text":"#include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); }","title":"Example"},{"location":"esp-01/dh11/","text":"Humidity Sensor DH11 How it works How to connect to ESP-01 How to program it The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"Humidity Sensor DH11"},{"location":"esp-01/dh11/#humidity-sensor-dh11","text":"","title":"Humidity Sensor DH11"},{"location":"esp-01/dh11/#how-it-works","text":"","title":"How it works"},{"location":"esp-01/dh11/#how-to-connect-to-esp-01","text":"","title":"How to connect to ESP-01"},{"location":"esp-01/dh11/#how-to-program-it","text":"The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"How to program it"},{"location":"esp-01/getting-started/","text":"Getting Started This file how to program in ESP-01. Configure Arduino IDE Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266! Connect USB device to ESP01 The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Getting Started"},{"location":"esp-01/getting-started/#getting-started","text":"This file how to program in ESP-01.","title":"Getting Started"},{"location":"esp-01/getting-started/#configure-arduino-ide","text":"Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266!","title":"Configure Arduino IDE"},{"location":"esp-01/getting-started/#connect-usb-device-to-esp01","text":"The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Connect USB device to ESP01"},{"location":"esp-01/lcd/","text":"LCD Screen DataSheets Technical Docs Code Library: SparkFun Graphic LCD Serial Backpack Example code: here How works You give the information of the pointer to start writing and, then, give the string. Configuration of the board The Rx of the LCD must be the Tx of the board and the other way around.","title":"LCD Screen"},{"location":"esp-01/lcd/#lcd-screen","text":"DataSheets Technical Docs","title":"LCD Screen"},{"location":"esp-01/lcd/#code","text":"Library: SparkFun Graphic LCD Serial Backpack Example code: here","title":"Code"},{"location":"esp-01/lcd/#how-works","text":"You give the information of the pointer to start writing and, then, give the string.","title":"How works"},{"location":"esp-01/lcd/#configuration-of-the-board","text":"The Rx of the LCD must be the Tx of the board and the other way around.","title":"Configuration of the board"}]}