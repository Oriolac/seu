{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wind Farm Project Project layout docs/ | - mkdocs.yml # The configuration file. | - docs/ | - index.md # The documentation homepage. | - ... # Other markdown pages, images and other files. examples/ # Folder with some examples that inspired us for | # building the project | - ticker # Tests if an ESP works | - ... resources/ # Folder with the resources used for | # the process, mainly libraries and fritzings | ... src/ # Folder with all the code | # for the components in the application | ... Publish to Github pages mkdocs gh-deploy will publish whatever the branch you are currently working on. Github Repository The link to the Github Repository can be found here . Github Project The link to the Github SCRUM Project can be found here . Slides done in the subject Sprint 1 Sprint 2 Sprint 3","title":"Wind Farm Project"},{"location":"#wind-farm-project","text":"","title":"Wind Farm Project"},{"location":"#project-layout","text":"docs/ | - mkdocs.yml # The configuration file. | - docs/ | - index.md # The documentation homepage. | - ... # Other markdown pages, images and other files. examples/ # Folder with some examples that inspired us for | # building the project | - ticker # Tests if an ESP works | - ... resources/ # Folder with the resources used for | # the process, mainly libraries and fritzings | ... src/ # Folder with all the code | # for the components in the application | ...","title":"Project layout"},{"location":"#publish-to-github-pages","text":"mkdocs gh-deploy will publish whatever the branch you are currently working on.","title":"Publish to Github pages"},{"location":"#github-repository","text":"The link to the Github Repository can be found here .","title":"Github Repository"},{"location":"#github-project","text":"The link to the Github SCRUM Project can be found here .","title":"Github Project"},{"location":"#slides-done-in-the-subject","text":"Sprint 1 Sprint 2 Sprint 3","title":"Slides done in the subject"},{"location":"Supervision-Station/Supervision-Station/","text":"Supervision In the image below is shown the prototype proposal of the Supervision station . Requirements The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker. User story Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station. As the last 24 hours is hard to debug, it is shown instead the last 24 values in the code. To change this, make the delay of requesting the data for an hour or compute the median for it. The schema Sequence diagram It shall be described the sequence diagrams used in the supervision station. ChibiOS and Arduino communication Arduino and ESP01 communication ChibiOS In order to find more information of ChibiOS, go here . ESP-01 Subscriber In order to find more information of ESP-01 Subscriber, go here .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#supervision","text":"In the image below is shown the prototype proposal of the Supervision station .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#requirements","text":"The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker.","title":"Requirements"},{"location":"Supervision-Station/Supervision-Station/#user-story","text":"Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station. As the last 24 hours is hard to debug, it is shown instead the last 24 values in the code. To change this, make the delay of requesting the data for an hour or compute the median for it.","title":"User story"},{"location":"Supervision-Station/Supervision-Station/#the-schema","text":"","title":"The schema"},{"location":"Supervision-Station/Supervision-Station/#sequence-diagram","text":"It shall be described the sequence diagrams used in the supervision station.","title":"Sequence diagram"},{"location":"Supervision-Station/Supervision-Station/#chibios-and-arduino-communication","text":"","title":"ChibiOS and Arduino communication"},{"location":"Supervision-Station/Supervision-Station/#arduino-and-esp01-communication","text":"","title":"Arduino and ESP01 communication"},{"location":"Supervision-Station/Supervision-Station/#chibios","text":"In order to find more information of ChibiOS, go here .","title":"ChibiOS"},{"location":"Supervision-Station/Supervision-Station/#esp-01-subscriber","text":"In order to find more information of ESP-01 Subscriber, go here .","title":"ESP-01 Subscriber"},{"location":"Supervision-Station/arduino/","text":"Arduino The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system. At first it will be discussed the I2C protocol implementation with an example. Then, it will be explained different approaches that we tried for the connection between ESP01 and Arduino. I2C Protocol for RPi B connection /* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: } ESP01 connection At first we tried to use AT commands, as we thought that it was easier than programming a whole protocol. But, after having some troubles to make the ESP01 work against the firmware, and having already a subscriber for the mqtt broker for the ESP01, we made a simple protocol from reading that corresponds as this: '0' -> \"test\" '1' -> dataproducer1 JSON '2' -> dataproducer2 JSON 'j' -> all the state as a JSON The options '0' and 'j' are meant to be used for debugging, and the options '1' and '2' are meant to be used by the arduino. This messages are terminated with a ';' for reasons discussed later. The arduino code The arduino has quite some troubles for parsing the data, as, sometimes, ESP01 adds some noise for the lasts characters. We think that the print library sends the entire size of the array instead of a marked '\\0' character array. For this reason, we added a peculiarity: it reads until the character ';', then it discards the rest of the buffer, as the Arduino didn't request for more characters. The example for this code is: #include <ArduinoJson.h>; char msg[512]; DynamicJsonDocument dataproducer1(256); DynamicJsonDocument dataproducer2(256); void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET DATAPRODUCER1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(dataproducer1); //GET DATAPRODUCER2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(dataproducer2); delay(2000); } Merge of both codes for Arduino Mega #include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); Serial.println(\"Sending dt1...\"); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); Serial.println(\"Sending dt2...\"); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); Serial.println(\"Sending dt1...\"); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); Serial.println(\"Sending debug\"); } void senddataproducer() { Serial.print(\"dataproducer(humidity=\"); Serial.print(dt1.humidity); Serial.print(\", temperature=\"); Serial.print(dt1.temperature); Serial.print(\", heatIndex=\"); Serial.print(dt1.heatIndex); Serial.print(\", x=\"); Serial.print(dt2.x); Serial.print(\", y=\"); Serial.print(dt2.y); Serial.print(\", z=\"); Serial.print(dt2.z); Serial.println(\");\"); if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); Serial.print(\"msg = \"); Serial.println(t); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(*dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET dataproducerJson1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); } Merge of both codes for Arduino Uno #include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); } void senddataproducer() { if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); while (Serial.available()>0){} Serial.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial.available()<=0){} delay(100); int i = 0; while(last_char != ';'){ if (Serial.available()>0){ msg[i] = (char)Serial.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); char c; while(Serial.available() > 0) { Serial.readBytes(&c, 1); } } void loop() { //GET dataproducerJson1 INFO Serial.write(\"1\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial.write(\"2\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); }","title":"Arduino"},{"location":"Supervision-Station/arduino/#arduino","text":"The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system. At first it will be discussed the I2C protocol implementation with an example. Then, it will be explained different approaches that we tried for the connection between ESP01 and Arduino.","title":"Arduino"},{"location":"Supervision-Station/arduino/#i2c-protocol-for-rpi-b-connection","text":"/* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: }","title":"I2C Protocol for RPi B connection"},{"location":"Supervision-Station/arduino/#esp01-connection","text":"At first we tried to use AT commands, as we thought that it was easier than programming a whole protocol. But, after having some troubles to make the ESP01 work against the firmware, and having already a subscriber for the mqtt broker for the ESP01, we made a simple protocol from reading that corresponds as this: '0' -> \"test\" '1' -> dataproducer1 JSON '2' -> dataproducer2 JSON 'j' -> all the state as a JSON The options '0' and 'j' are meant to be used for debugging, and the options '1' and '2' are meant to be used by the arduino. This messages are terminated with a ';' for reasons discussed later.","title":"ESP01 connection"},{"location":"Supervision-Station/arduino/#the-arduino-code","text":"The arduino has quite some troubles for parsing the data, as, sometimes, ESP01 adds some noise for the lasts characters. We think that the print library sends the entire size of the array instead of a marked '\\0' character array. For this reason, we added a peculiarity: it reads until the character ';', then it discards the rest of the buffer, as the Arduino didn't request for more characters. The example for this code is: #include <ArduinoJson.h>; char msg[512]; DynamicJsonDocument dataproducer1(256); DynamicJsonDocument dataproducer2(256); void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET DATAPRODUCER1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(dataproducer1); //GET DATAPRODUCER2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(dataproducer2); delay(2000); }","title":"The arduino code"},{"location":"Supervision-Station/arduino/#merge-of-both-codes-for-arduino-mega","text":"#include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); Serial.println(\"Sending dt1...\"); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); Serial.println(\"Sending dt2...\"); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); Serial.println(\"Sending dt1...\"); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); Serial.println(\"Sending debug\"); } void senddataproducer() { Serial.print(\"dataproducer(humidity=\"); Serial.print(dt1.humidity); Serial.print(\", temperature=\"); Serial.print(dt1.temperature); Serial.print(\", heatIndex=\"); Serial.print(dt1.heatIndex); Serial.print(\", x=\"); Serial.print(dt2.x); Serial.print(\", y=\"); Serial.print(dt2.y); Serial.print(\", z=\"); Serial.print(dt2.z); Serial.println(\");\"); if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); Serial.print(\"msg = \"); Serial.println(t); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(*dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET dataproducerJson1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); }","title":"Merge of both codes for Arduino Mega"},{"location":"Supervision-Station/arduino/#merge-of-both-codes-for-arduino-uno","text":"#include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); } void senddataproducer() { if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); while (Serial.available()>0){} Serial.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial.available()<=0){} delay(100); int i = 0; while(last_char != ';'){ if (Serial.available()>0){ msg[i] = (char)Serial.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); char c; while(Serial.available() > 0) { Serial.readBytes(&c, 1); } } void loop() { //GET dataproducerJson1 INFO Serial.write(\"1\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial.write(\"2\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); }","title":"Merge of both codes for Arduino Uno"},{"location":"Supervision-Station/chibios/","text":"ChibiOS Introduction Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling How works? Requirements Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Demos The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img . LCD Screen For LCD Screen, there is an example of that below. In the code, there has been added new functions to draw the graph of the data of the sensors, it is explained here . #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; } The LCD Screen has some several issues about printing the floats, so it has been changed the chprintf.h , specifically, ftoa to not only change the precision of the float but also fix some bugs: #define FLOAT_PRECISION 100 static char *ftoa(char *p, double num) { long l; unsigned long precision = FLOAT_PRECISION; l = (long) num; p = long_to_string_with_divisor(p, l, 10, 0); *p++ = '.'; l = (long)((num - l) * precision); return long_to_string_with_divisor(p, l, 10, precision / 10); } Also, some macros have been created in order to set the different consants such as the total number of data saved in every dataproducer (20), or graphic LCD constants: #define MAX_DATA_UNITS 20 #define START_DRAW_X 0x1D #define MAX_X 0x79 #define MAX_Y_GRAPH 0x31 Arduino I2C ChibiOS has a function to request the information on I2C bus, and in this document it shall be described how it works. The data is received through this function: void i2cMasterTransmitTimeout( &I2C0, // I2C bus // the address that you are requesting information arduino_address, NULL,// the request information 0, // size sended in the request information (uint8_t *)&data, // data received sizeof(sensor_data_t), // size of the data received MS2ST(1000) // I don't really know anything about this ); Code of I2C #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; } Code Regarding drawing and displaying the graph in the LCD Screen, to know how to draw the lines it has been searched the code of LCD Sparkfun Backpack and it has been created several functions such as set_x , set_y , clear_screen , drawLine to manage the LCD Screen. #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" #include \"chvt.h\" #include <string.h> #define N 10 #define TEMPERATURE_STATE 0 #define HUMIDITY_STATE 1 #define HEAT_INDEX 2 #define ACCEL_STATE_X 3 #define ACCEL_STATE_Y 4 #define ACCEL_STATE_Z 5 #define MAX_DATA_UNITS 20 #define START_DRAW_X 0x1D #define MAX_X 0x79 #define MAX_Y_GRAPH 0x31 #define GET_VALUE(field, comparation) \\ res = data_units[0].field; \\ for (int i = 1; i < length; i++) \\ { \\ if (data_units[i].field comparation res) \\ res = data_units[i].field; \\ } static const uint8_t arduino_address = 0x04; struct data_unit_t { float humidity; float temperature; float heat_index; float accelerometerX; float accelerometerY; float accelerometerZ; }; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct { float x; float y; float z; } dataproducer2; struct data_unit_t data_units[MAX_DATA_UNITS]; int length; int num_dtp; struct data_t *data; dataproducer2 dt2; msg_t msgDt2; dataproducer1 dt1; msg_t msgDt1; float get_attribute(int state, int i); void drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2); void add_struct_data_unit(int state); void display_float(float f); void display_int(int i); void set_position(uint8_t x, uint8_t y); void clear_screen(void); void set_x(uint8_t x); void set_y(uint8_t y); char *get_title(int state); void add_data(float humidity, float temperature, float heat_index, float accelX, float accelY, float accelZ); void shift_data(void); float get_min_value(int state); float get_max_value(int state); void printDataDt1(void); static WORKING_AREA(waThread_LED1, 128); static WORKING_AREA(waThread_LCD, 128); static WORKING_AREA(waThread_I2C, 256); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); char *title; int state = TEMPERATURE_STATE; while (TRUE) { float min_val = get_min_value(state); float max_val = get_max_value(state); set_position(0x00, 0x3D); title = get_title(state); chprintf((BaseSequentialStream *)&SD1, \"%s %d:\", title, num_dtp); chThdSleepMilliseconds(10); drawLine(START_DRAW_X, 0x00, START_DRAW_X, 0x31); set_position(0x00, 0x31); display_float(max_val); set_position(0x00, 0x07); display_float(min_val); max_val++; min_val--; for (int i = length - 1; i > 0; i--) { float last = get_attribute(state, i); float start = get_attribute(state, i - 1); int x_offset = MAX_DATA_UNITS - length + i; int x_last = START_DRAW_X + x_offset * 5; int x_start = START_DRAW_X + (x_offset - 1) * 5; int y_last = (last - min_val) / (max_val - min_val) * MAX_Y_GRAPH; int y_start = (start - min_val) / (max_val - min_val) * MAX_Y_GRAPH; drawLine(x_start, y_start, x_last, y_last); } state = (state + 1) % ACCEL_STATE_Z; chThdSleepMilliseconds(3000); clear_screen(); } return 0; } float get_attribute(int state, int i) { switch (state) { case TEMPERATURE_STATE: return data_units[i].temperature; case HUMIDITY_STATE: return data_units[i].humidity; case HEAT_INDEX: return data_units[i].heat_index; case ACCEL_STATE_X: return data_units[i].accelerometerX; case ACCEL_STATE_Y: return data_units[i].accelerometerY; default: return data_units[i].accelerometerZ; } } void display_int(int i) { chprintf((BaseSequentialStream *)&SD1, \"%d\", (int)i); chThdSleepMilliseconds(500); } void display_float(float f) { chprintf((BaseSequentialStream *)&SD1, \"%f\", (float)f); chThdSleepMilliseconds(500); } float get_min_value(int state) { float res = -1; switch (state) { case TEMPERATURE_STATE: GET_VALUE(temperature, <); break; case HUMIDITY_STATE: GET_VALUE(humidity, <); break; case HEAT_INDEX: GET_VALUE(heat_index, <); break; case ACCEL_STATE_X: GET_VALUE(accelerometerX, <); break; case ACCEL_STATE_Y: GET_VALUE(accelerometerY, <); break; default: GET_VALUE(accelerometerZ, <); break; } return res; } float get_max_value(int state) { float res = -1; switch (state) { case TEMPERATURE_STATE: GET_VALUE(temperature, >); break; case HUMIDITY_STATE: GET_VALUE(humidity, >); break; case HEAT_INDEX: GET_VALUE(heat_index, >); break; case ACCEL_STATE_X: GET_VALUE(accelerometerX, >); break; case ACCEL_STATE_Y: GET_VALUE(accelerometerY, >); break; default: GET_VALUE(accelerometerZ, >); break; } return res; } char *get_title(int state) { switch (state) { case TEMPERATURE_STATE: return \"Temperature\"; case HUMIDITY_STATE: return \"Humidity\"; case HEAT_INDEX: return \"Heat index\"; case ACCEL_STATE_X: return \"Accelerometer x\"; case ACCEL_STATE_Y: return \"Accelerometer y\"; default: return \"Accelerometer z\"; } } void receiveSilentDt2(void) { const uint8_t t = 0x01; msgDt2 = i2cMasterTransmitTimeout(&I2C0, arduino_address, &t, 1, (uint8_t *)&dt2, sizeof(dataproducer2), MS2ST(1000)); chThdSleepMilliseconds(3500); } void receiveSilentDt1(void) { const uint8_t t = 0x00; msgDt1 = i2cMasterTransmitTimeout(&I2C0, arduino_address, &t, 1, (uint8_t *)&dt1, sizeof(dataproducer1), MS2ST(1000)); chThdSleepMilliseconds(3500); } static msg_t Thread_LED1(void *p) { (void)p; chRegSetThreadName(\"blinker-1\"); while (TRUE) { printDataDt1(); chThdSleepMilliseconds(3500); // chThdYield(); } return 0; } void printDataDt1(void) { add_data(dt1.humidity, dt1.temperature, dt1.heatIndex, dt2.x, dt2.y, dt2.z); switch (msgDt1) { case Q_TIMEOUT: break; case Q_OK: break; case Q_RESET: chprintf((BaseSequentialStream *)&SD1, \"Reset: %d\", msgDt1); i2cflags_t i2cFlags = i2cGetErrors(&I2C0); chprintf((BaseSequentialStream *)&SD1, \"Flags: %d\", i2cFlags); I2CConfig i2cConfig; i2cStop(&I2C0); i2cStart(&I2C0, &i2cConfig); break; default: break; } } static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"Read all the information in I2C\"); dt1.humidity = 0.33f; dt1.temperature = 2.33f; dt1.heatIndex = 0.55f; while (TRUE) { receiveSilentDt1(); receiveSilentDt2(); // receiveSilently12Chars(); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); length = 0; sdStart(&SD1, NULL); I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_LED1, sizeof(waThread_LED1), HIGHPRIO, Thread_LED1, NULL); chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), ABSPRIO, Thread_I2C, NULL); chThdWait(chThdSelf()); return 0; } void set_x(uint8_t x) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)x); chThdSleepMilliseconds(10); } void set_y(uint8_t y) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)y); chThdSleepMilliseconds(10); } void set_position(uint8_t x, uint8_t y) { set_x(x); set_y(y); } void drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) { //draws a line from two given points. You can set and reset just as the pixel function. sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x0C); //CTRL l sdPut(&SD1, (uint8_t)x1); sdPut(&SD1, (uint8_t)y1); sdPut(&SD1, (uint8_t)x2); sdPut(&SD1, (uint8_t)y2); sdPut(&SD1, (uint8_t)0x01); chThdSleepMilliseconds(10); } void clear_screen(void) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, 0x00); } void add_data(float humidity, float temperature, float heat_index, float accelX, float accelY, float accelZ) { if (length < MAX_DATA_UNITS) { struct data_unit_t data_unit; memset(&data_unit, 0, sizeof(struct data_unit_t)); data_unit.humidity = humidity; data_unit.temperature = temperature; data_unit.heat_index = heat_index; data_unit.accelerometerX = accelX; data_unit.accelerometerY = accelY; data_unit.accelerometerZ = accelZ; data_units[length] = data_unit; length++; } else { shift_data(); data_units[MAX_DATA_UNITS - 1].humidity = humidity; data_units[MAX_DATA_UNITS - 1].temperature = temperature; data_units[MAX_DATA_UNITS - 1].heat_index = heat_index; data_units[MAX_DATA_UNITS - 1].accelerometerX = accelX; data_units[MAX_DATA_UNITS - 1].accelerometerY = accelY; data_units[MAX_DATA_UNITS - 1].accelerometerZ = accelZ; } } void shift_data(void) { for (int i = 1; i < MAX_DATA_UNITS; i++) { data_units[i - 1] = data_units[i]; } }","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#chibios","text":"","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#introduction","text":"Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling","title":"Introduction"},{"location":"Supervision-Station/chibios/#how-works","text":"","title":"How works?"},{"location":"Supervision-Station/chibios/#requirements","text":"Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.","title":"Requirements"},{"location":"Supervision-Station/chibios/#demos","text":"The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img .","title":"Demos"},{"location":"Supervision-Station/chibios/#lcd-screen","text":"For LCD Screen, there is an example of that below. In the code, there has been added new functions to draw the graph of the data of the sensors, it is explained here . #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; } The LCD Screen has some several issues about printing the floats, so it has been changed the chprintf.h , specifically, ftoa to not only change the precision of the float but also fix some bugs: #define FLOAT_PRECISION 100 static char *ftoa(char *p, double num) { long l; unsigned long precision = FLOAT_PRECISION; l = (long) num; p = long_to_string_with_divisor(p, l, 10, 0); *p++ = '.'; l = (long)((num - l) * precision); return long_to_string_with_divisor(p, l, 10, precision / 10); } Also, some macros have been created in order to set the different consants such as the total number of data saved in every dataproducer (20), or graphic LCD constants: #define MAX_DATA_UNITS 20 #define START_DRAW_X 0x1D #define MAX_X 0x79 #define MAX_Y_GRAPH 0x31","title":"LCD Screen"},{"location":"Supervision-Station/chibios/#arduino-i2c","text":"ChibiOS has a function to request the information on I2C bus, and in this document it shall be described how it works. The data is received through this function: void i2cMasterTransmitTimeout( &I2C0, // I2C bus // the address that you are requesting information arduino_address, NULL,// the request information 0, // size sended in the request information (uint8_t *)&data, // data received sizeof(sensor_data_t), // size of the data received MS2ST(1000) // I don't really know anything about this );","title":"Arduino I2C"},{"location":"Supervision-Station/chibios/#code-of-i2c","text":"#include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; }","title":"Code of I2C"},{"location":"Supervision-Station/chibios/#code","text":"Regarding drawing and displaying the graph in the LCD Screen, to know how to draw the lines it has been searched the code of LCD Sparkfun Backpack and it has been created several functions such as set_x , set_y , clear_screen , drawLine to manage the LCD Screen. #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" #include \"chvt.h\" #include <string.h> #define N 10 #define TEMPERATURE_STATE 0 #define HUMIDITY_STATE 1 #define HEAT_INDEX 2 #define ACCEL_STATE_X 3 #define ACCEL_STATE_Y 4 #define ACCEL_STATE_Z 5 #define MAX_DATA_UNITS 20 #define START_DRAW_X 0x1D #define MAX_X 0x79 #define MAX_Y_GRAPH 0x31 #define GET_VALUE(field, comparation) \\ res = data_units[0].field; \\ for (int i = 1; i < length; i++) \\ { \\ if (data_units[i].field comparation res) \\ res = data_units[i].field; \\ } static const uint8_t arduino_address = 0x04; struct data_unit_t { float humidity; float temperature; float heat_index; float accelerometerX; float accelerometerY; float accelerometerZ; }; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct { float x; float y; float z; } dataproducer2; struct data_unit_t data_units[MAX_DATA_UNITS]; int length; int num_dtp; struct data_t *data; dataproducer2 dt2; msg_t msgDt2; dataproducer1 dt1; msg_t msgDt1; float get_attribute(int state, int i); void drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2); void add_struct_data_unit(int state); void display_float(float f); void display_int(int i); void set_position(uint8_t x, uint8_t y); void clear_screen(void); void set_x(uint8_t x); void set_y(uint8_t y); char *get_title(int state); void add_data(float humidity, float temperature, float heat_index, float accelX, float accelY, float accelZ); void shift_data(void); float get_min_value(int state); float get_max_value(int state); void printDataDt1(void); static WORKING_AREA(waThread_LED1, 128); static WORKING_AREA(waThread_LCD, 128); static WORKING_AREA(waThread_I2C, 256); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); char *title; int state = TEMPERATURE_STATE; while (TRUE) { float min_val = get_min_value(state); float max_val = get_max_value(state); set_position(0x00, 0x3D); title = get_title(state); chprintf((BaseSequentialStream *)&SD1, \"%s %d:\", title, num_dtp); chThdSleepMilliseconds(10); drawLine(START_DRAW_X, 0x00, START_DRAW_X, 0x31); set_position(0x00, 0x31); display_float(max_val); set_position(0x00, 0x07); display_float(min_val); max_val++; min_val--; for (int i = length - 1; i > 0; i--) { float last = get_attribute(state, i); float start = get_attribute(state, i - 1); int x_offset = MAX_DATA_UNITS - length + i; int x_last = START_DRAW_X + x_offset * 5; int x_start = START_DRAW_X + (x_offset - 1) * 5; int y_last = (last - min_val) / (max_val - min_val) * MAX_Y_GRAPH; int y_start = (start - min_val) / (max_val - min_val) * MAX_Y_GRAPH; drawLine(x_start, y_start, x_last, y_last); } state = (state + 1) % ACCEL_STATE_Z; chThdSleepMilliseconds(3000); clear_screen(); } return 0; } float get_attribute(int state, int i) { switch (state) { case TEMPERATURE_STATE: return data_units[i].temperature; case HUMIDITY_STATE: return data_units[i].humidity; case HEAT_INDEX: return data_units[i].heat_index; case ACCEL_STATE_X: return data_units[i].accelerometerX; case ACCEL_STATE_Y: return data_units[i].accelerometerY; default: return data_units[i].accelerometerZ; } } void display_int(int i) { chprintf((BaseSequentialStream *)&SD1, \"%d\", (int)i); chThdSleepMilliseconds(500); } void display_float(float f) { chprintf((BaseSequentialStream *)&SD1, \"%f\", (float)f); chThdSleepMilliseconds(500); } float get_min_value(int state) { float res = -1; switch (state) { case TEMPERATURE_STATE: GET_VALUE(temperature, <); break; case HUMIDITY_STATE: GET_VALUE(humidity, <); break; case HEAT_INDEX: GET_VALUE(heat_index, <); break; case ACCEL_STATE_X: GET_VALUE(accelerometerX, <); break; case ACCEL_STATE_Y: GET_VALUE(accelerometerY, <); break; default: GET_VALUE(accelerometerZ, <); break; } return res; } float get_max_value(int state) { float res = -1; switch (state) { case TEMPERATURE_STATE: GET_VALUE(temperature, >); break; case HUMIDITY_STATE: GET_VALUE(humidity, >); break; case HEAT_INDEX: GET_VALUE(heat_index, >); break; case ACCEL_STATE_X: GET_VALUE(accelerometerX, >); break; case ACCEL_STATE_Y: GET_VALUE(accelerometerY, >); break; default: GET_VALUE(accelerometerZ, >); break; } return res; } char *get_title(int state) { switch (state) { case TEMPERATURE_STATE: return \"Temperature\"; case HUMIDITY_STATE: return \"Humidity\"; case HEAT_INDEX: return \"Heat index\"; case ACCEL_STATE_X: return \"Accelerometer x\"; case ACCEL_STATE_Y: return \"Accelerometer y\"; default: return \"Accelerometer z\"; } } void receiveSilentDt2(void) { const uint8_t t = 0x01; msgDt2 = i2cMasterTransmitTimeout(&I2C0, arduino_address, &t, 1, (uint8_t *)&dt2, sizeof(dataproducer2), MS2ST(1000)); chThdSleepMilliseconds(3500); } void receiveSilentDt1(void) { const uint8_t t = 0x00; msgDt1 = i2cMasterTransmitTimeout(&I2C0, arduino_address, &t, 1, (uint8_t *)&dt1, sizeof(dataproducer1), MS2ST(1000)); chThdSleepMilliseconds(3500); } static msg_t Thread_LED1(void *p) { (void)p; chRegSetThreadName(\"blinker-1\"); while (TRUE) { printDataDt1(); chThdSleepMilliseconds(3500); // chThdYield(); } return 0; } void printDataDt1(void) { add_data(dt1.humidity, dt1.temperature, dt1.heatIndex, dt2.x, dt2.y, dt2.z); switch (msgDt1) { case Q_TIMEOUT: break; case Q_OK: break; case Q_RESET: chprintf((BaseSequentialStream *)&SD1, \"Reset: %d\", msgDt1); i2cflags_t i2cFlags = i2cGetErrors(&I2C0); chprintf((BaseSequentialStream *)&SD1, \"Flags: %d\", i2cFlags); I2CConfig i2cConfig; i2cStop(&I2C0); i2cStart(&I2C0, &i2cConfig); break; default: break; } } static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"Read all the information in I2C\"); dt1.humidity = 0.33f; dt1.temperature = 2.33f; dt1.heatIndex = 0.55f; while (TRUE) { receiveSilentDt1(); receiveSilentDt2(); // receiveSilently12Chars(); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); length = 0; sdStart(&SD1, NULL); I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_LED1, sizeof(waThread_LED1), HIGHPRIO, Thread_LED1, NULL); chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), ABSPRIO, Thread_I2C, NULL); chThdWait(chThdSelf()); return 0; } void set_x(uint8_t x) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)x); chThdSleepMilliseconds(10); } void set_y(uint8_t y) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)y); chThdSleepMilliseconds(10); } void set_position(uint8_t x, uint8_t y) { set_x(x); set_y(y); } void drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) { //draws a line from two given points. You can set and reset just as the pixel function. sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x0C); //CTRL l sdPut(&SD1, (uint8_t)x1); sdPut(&SD1, (uint8_t)y1); sdPut(&SD1, (uint8_t)x2); sdPut(&SD1, (uint8_t)y2); sdPut(&SD1, (uint8_t)0x01); chThdSleepMilliseconds(10); } void clear_screen(void) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, 0x00); } void add_data(float humidity, float temperature, float heat_index, float accelX, float accelY, float accelZ) { if (length < MAX_DATA_UNITS) { struct data_unit_t data_unit; memset(&data_unit, 0, sizeof(struct data_unit_t)); data_unit.humidity = humidity; data_unit.temperature = temperature; data_unit.heat_index = heat_index; data_unit.accelerometerX = accelX; data_unit.accelerometerY = accelY; data_unit.accelerometerZ = accelZ; data_units[length] = data_unit; length++; } else { shift_data(); data_units[MAX_DATA_UNITS - 1].humidity = humidity; data_units[MAX_DATA_UNITS - 1].temperature = temperature; data_units[MAX_DATA_UNITS - 1].heat_index = heat_index; data_units[MAX_DATA_UNITS - 1].accelerometerX = accelX; data_units[MAX_DATA_UNITS - 1].accelerometerY = accelY; data_units[MAX_DATA_UNITS - 1].accelerometerZ = accelZ; } } void shift_data(void) { for (int i = 1; i < MAX_DATA_UNITS; i++) { data_units[i - 1] = data_units[i]; } }","title":"Code"},{"location":"Supervision-Station/esp01/","text":"ESP-01 Subscriber This component is the one that has the responsability of subscribing to the different topics that we deffined in the MQTT broker to retrieve the information sent by the data producer. AT Commands Failure As a first try to tackle this part of the supervision station, we tried to flash the AT Commands firmware that was provided into the ESP-01. Doing it this way, we would had the ESP as a slave of the arduino, leting us work and to build all the code in the arduino part. For flashing the firmware into the ESP we used a python tool called esptool built by the manofacturers of the chip. This never worked and a lot of time was expended trying to make it work. Furthermore, we tryed to send AT commands directly thorugh the serial with the ESP connected into one USB port of our computer and it did not work. For this reason we decided to implemented our own protocol. ESP-01 Protocol The ESP mantains allways the latest data that has arribed thorugh te MQTT and parallely it's listening through the serials to some predefined commands that arduino sends to request the data. These commands are described in Supervision Station/Arduino section. ESP-01 code #include <ESP8266WiFi.h> #include <PubSubClient.h> #include <Dictionary.h> const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; const char* clientID = \"consumer\"; const char* clientUserName = \"consumer\"; const char* clientPassword = \"password\"; Dictionary *mapper = new Dictionary(6); Dictionary &dataproducer1 = *(new Dictionary(3)); Dictionary &dataproducer2 = *(new Dictionary(3)); Dictionary &data = *(new Dictionary(6)); WiFiClient espClient; PubSubClient client(espClient); int value = 0; char request; String response; void setup_wifi() { delay(10); // We start by connecting to a WiFi network WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void callback(char* topic, byte* payload, unsigned int len) { char msg[len+2]; for (int i = 0; i < len; i++) { msg[i] = (char)payload[i]; } msg[len] = ';'; msg[len+1] = '\\0'; if(len > 21 && topic[21] == '1'){ data(\"dataproducer1\", msg); }else if (len > 21 && topic[21] == '2' ){ data(\"dataproducer2\", msg); } data.remove(\"json\"); data(\"json\", data.json()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Attempt to connect if (!client.connect(clientID)) { // Wait 5 seconds before retrying delay(5000); }else{ Serial.write('i'); } } } void setup() { pinMode(BUILTIN_LED, OUTPUT); // Initialize the BUILTIN_LED pin as an output Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server, 1883); client.setCallback(callback); client.connect(clientID,clientUserName,clientPassword); client.subscribe(\"windmill/dataproducer1\"); client.subscribe(\"windmill/dataproducer2\"); mapper->insert(\"0\", \"ping\"); mapper->insert(\"1\", \"dataproducer1\"); mapper->insert(\"2\", \"dataproducer2\"); mapper->insert(\"j\", \"json\"); data(\"ping\", \"test\"); Serial.write('i'); } void loop() { if(!client.connected()){ reconnect(); } client.loop(); if(Serial.available()){ request = (char)Serial.read(); Serial.println(data[mapper->search((String)request)]); } }","title":"ESP-01 Subscriber"},{"location":"Supervision-Station/esp01/#esp-01-subscriber","text":"This component is the one that has the responsability of subscribing to the different topics that we deffined in the MQTT broker to retrieve the information sent by the data producer.","title":"ESP-01 Subscriber"},{"location":"Supervision-Station/esp01/#at-commands-failure","text":"As a first try to tackle this part of the supervision station, we tried to flash the AT Commands firmware that was provided into the ESP-01. Doing it this way, we would had the ESP as a slave of the arduino, leting us work and to build all the code in the arduino part. For flashing the firmware into the ESP we used a python tool called esptool built by the manofacturers of the chip. This never worked and a lot of time was expended trying to make it work. Furthermore, we tryed to send AT commands directly thorugh the serial with the ESP connected into one USB port of our computer and it did not work. For this reason we decided to implemented our own protocol.","title":"AT Commands Failure"},{"location":"Supervision-Station/esp01/#esp-01-protocol","text":"The ESP mantains allways the latest data that has arribed thorugh te MQTT and parallely it's listening through the serials to some predefined commands that arduino sends to request the data. These commands are described in Supervision Station/Arduino section.","title":"ESP-01 Protocol"},{"location":"Supervision-Station/esp01/#esp-01-code","text":"#include <ESP8266WiFi.h> #include <PubSubClient.h> #include <Dictionary.h> const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; const char* clientID = \"consumer\"; const char* clientUserName = \"consumer\"; const char* clientPassword = \"password\"; Dictionary *mapper = new Dictionary(6); Dictionary &dataproducer1 = *(new Dictionary(3)); Dictionary &dataproducer2 = *(new Dictionary(3)); Dictionary &data = *(new Dictionary(6)); WiFiClient espClient; PubSubClient client(espClient); int value = 0; char request; String response; void setup_wifi() { delay(10); // We start by connecting to a WiFi network WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void callback(char* topic, byte* payload, unsigned int len) { char msg[len+2]; for (int i = 0; i < len; i++) { msg[i] = (char)payload[i]; } msg[len] = ';'; msg[len+1] = '\\0'; if(len > 21 && topic[21] == '1'){ data(\"dataproducer1\", msg); }else if (len > 21 && topic[21] == '2' ){ data(\"dataproducer2\", msg); } data.remove(\"json\"); data(\"json\", data.json()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Attempt to connect if (!client.connect(clientID)) { // Wait 5 seconds before retrying delay(5000); }else{ Serial.write('i'); } } } void setup() { pinMode(BUILTIN_LED, OUTPUT); // Initialize the BUILTIN_LED pin as an output Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server, 1883); client.setCallback(callback); client.connect(clientID,clientUserName,clientPassword); client.subscribe(\"windmill/dataproducer1\"); client.subscribe(\"windmill/dataproducer2\"); mapper->insert(\"0\", \"ping\"); mapper->insert(\"1\", \"dataproducer1\"); mapper->insert(\"2\", \"dataproducer2\"); mapper->insert(\"j\", \"json\"); data(\"ping\", \"test\"); Serial.write('i'); } void loop() { if(!client.connected()){ reconnect(); } client.loop(); if(Serial.available()){ request = (char)Serial.read(); Serial.println(data[mapper->search((String)request)]); } }","title":"ESP-01 code"},{"location":"dataproducer-1/dataproducer-1/","text":"Dataproducer 1 Components Temperature and humidity sensor LCD screen ESP-01 Flux Wiring Bugs encountered We put a cable in a pin on the breadboard that didn't work at all. We spend a couple of hours debugging it. Code #include \"DHT.h\" #include <ESP8266WiFi.h> #include <PubSubClient.h> #define maxX 127//159 #define maxY 63 //127 const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; WiFiClient espClient; PubSubClient client(espClient); unsigned long lastMsg = 0; #define MSG_BUFFER_SIZE (50) char msg[MSG_BUFFER_SIZE]; DHT dht(2, DHT11); /* OUR FUNCTIONS */ void setup_wifi() { delay(10); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Create a random client ID String clientId = \"ESP8266Client-\"; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str())) { client.publish(\"debug\",\"connected\"); client.publish(\"outTopic\", \"hello world\"); } else { // Wait 5 seconds before retrying delay(5000); } } } void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial.write(0x7C); Serial.write(0x18);//CTRL x Serial.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial.write(0x7C); Serial.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial.write(0x7C); Serial.write(0x19);//CTRL y Serial.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { setup_wifi(); client.setServer(mqtt_server, 1883); dht.begin(); Serial.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial.print(\"Starting dataproducer1\"); delay(1000); Serial.print(\"Connecting to MQTT\"); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial.print(\"Temperature = \"); Serial.print(tempC); Serial.print(\"C \"); Serial.print(\"Humidity = \"); Serial.print(humidity); Serial.print(\"% \"); Serial.print(\"Heat index = \"); Serial.print(heatIndex); Serial.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) if (!client.connected()) { reconnect(); } client.loop(); float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { client.publish(\"debug\",\"Failed to read from DHT sensor!\"); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); unsigned long now = millis(); if (now - lastMsg > 2000) { sprintf(msg, \"{\\\"humidity\\\":%f,\\\"temperature\\\":%f,\\\"hic\\\":%f}\", h, t, hic); client.publish(\"debug\", \"Published message\"); client.publish(\"debug\",\"Publish message: \"); client.publish(\"debug\",msg); client.publish(\"windmill/dataproducer1\", msg); } } client.publish(\"debug\", \"Finished Message Sending\"); // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#dataproducer-1","text":"","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#components","text":"Temperature and humidity sensor LCD screen ESP-01","title":"Components"},{"location":"dataproducer-1/dataproducer-1/#flux","text":"","title":"Flux"},{"location":"dataproducer-1/dataproducer-1/#wiring","text":"","title":"Wiring"},{"location":"dataproducer-1/dataproducer-1/#bugs-encountered","text":"We put a cable in a pin on the breadboard that didn't work at all. We spend a couple of hours debugging it.","title":"Bugs encountered"},{"location":"dataproducer-1/dataproducer-1/#code","text":"#include \"DHT.h\" #include <ESP8266WiFi.h> #include <PubSubClient.h> #define maxX 127//159 #define maxY 63 //127 const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; WiFiClient espClient; PubSubClient client(espClient); unsigned long lastMsg = 0; #define MSG_BUFFER_SIZE (50) char msg[MSG_BUFFER_SIZE]; DHT dht(2, DHT11); /* OUR FUNCTIONS */ void setup_wifi() { delay(10); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Create a random client ID String clientId = \"ESP8266Client-\"; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str())) { client.publish(\"debug\",\"connected\"); client.publish(\"outTopic\", \"hello world\"); } else { // Wait 5 seconds before retrying delay(5000); } } } void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial.write(0x7C); Serial.write(0x18);//CTRL x Serial.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial.write(0x7C); Serial.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial.write(0x7C); Serial.write(0x19);//CTRL y Serial.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { setup_wifi(); client.setServer(mqtt_server, 1883); dht.begin(); Serial.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial.print(\"Starting dataproducer1\"); delay(1000); Serial.print(\"Connecting to MQTT\"); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial.print(\"Temperature = \"); Serial.print(tempC); Serial.print(\"C \"); Serial.print(\"Humidity = \"); Serial.print(humidity); Serial.print(\"% \"); Serial.print(\"Heat index = \"); Serial.print(heatIndex); Serial.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) if (!client.connected()) { reconnect(); } client.loop(); float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { client.publish(\"debug\",\"Failed to read from DHT sensor!\"); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); unsigned long now = millis(); if (now - lastMsg > 2000) { sprintf(msg, \"{\\\"humidity\\\":%f,\\\"temperature\\\":%f,\\\"hic\\\":%f}\", h, t, hic); client.publish(\"debug\", \"Published message\"); client.publish(\"debug\",\"Publish message: \"); client.publish(\"debug\",msg); client.publish(\"windmill/dataproducer1\", msg); } } client.publish(\"debug\", \"Finished Message Sending\"); // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Code"},{"location":"dataproducer-1/dht11/","text":"Humidity Sensor DH11 How it works How to connect to ESP-01 How to program it The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#humidity-sensor-dh11","text":"","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#how-it-works","text":"","title":"How it works"},{"location":"dataproducer-1/dht11/#how-to-connect-to-esp-01","text":"","title":"How to connect to ESP-01"},{"location":"dataproducer-1/dht11/#how-to-program-it","text":"The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"How to program it"},{"location":"dataproducer-1/graphical-lcd-backpack/","text":"Graphical LCD Backpack This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer. Connexions Example #include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#graphical-lcd-backpack","text":"This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer.","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#connexions","text":"","title":"Connexions"},{"location":"dataproducer-1/graphical-lcd-backpack/#example","text":"#include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Example"},{"location":"dataproducer-2/accelerometer/","text":"Accelerometer In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example. Instalation To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor. Initialization Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width } Example #include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#accelerometer","text":"In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example.","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#instalation","text":"To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor.","title":"Instalation"},{"location":"dataproducer-2/accelerometer/#initialization","text":"Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width }","title":"Initialization"},{"location":"dataproducer-2/accelerometer/#example","text":"#include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Example"},{"location":"dataproducer-2/dataproducer-2/","text":"Data producer 2 Components ESP-01 I2C bus Accelerometer LCD display Flux Wiring Examples that is based the code Broker publisher example LED I2C display example Accelerometer example Wires Code #include <LiquidCrystal_I2C.h> /* Dataproducer 2 * * */ #include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> #include <Wire.h> // libreria de comunicacion por I2C #include <ESP8266WiFi.h> #include <PubSubClient.h> const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; WiFiClient espClient; PubSubClient client(espClient); unsigned long lastMsg = 0; #define MSG_BUFFER_SIZE (50) char msg[MSG_BUFFER_SIZE]; Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); LiquidCrystal_I2C lcd(0x27, 16, 2); // DIR, E, RW, RS, D4, D5, D6, D7 void setup_wifi() { delay(10); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Create a random client ID String clientId = \"ESP8266Client-\"; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str())) { client.publish(\"debug\",\"connected\"); client.publish(\"outTopic\", \"hello world\"); } else { // Wait 5 seconds before retrying delay(5000); } } } void setup() { Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server, 1883); client.publish(\"debug\", \"Setting LCD communication\"); lcd.setBacklight(HIGH); // habilita iluminacion posterior de LCD lcd.begin(0, 2); // 16 columnas por 2 lineas para LCD 1602A lcd.clear(); // limpia pantalla if (!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ client.publish(\"debug\", \"Ooops, no ADXL345 detected ... Check your wiring!\"); while (1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { if (!client.connected()) { reconnect(); } client.loop(); sensors_event_t event; accel.getEvent(&event); client.publish(\"debug\", \"Displaying information at LCD SCReen: \"); lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"X:\"); lcd.print(event.acceleration.x); lcd.print(\" Y:\"); lcd.print(event.acceleration.y);// escribe el texto lcd.setCursor(0, 1); lcd.print(\"Z: \"); lcd.print(event.acceleration.z);// ubica cursor en columna 0 y linea 1 unsigned long now = millis(); if (now - lastMsg > 2000) { sprintf(msg, \"{\\\"X\\\":%f,\\\"Y\\\":%f,\\\"Z\\\":%f}\", event.acceleration.x, event.acceleration.y, event.acceleration.z); client.publish(\"debug\", \"Published message\"); client.publish(\"debug\",\"Publish message: \"); client.publish(\"debug\",msg); client.publish(\"windmill/dataproducer2\", msg); } client.publish(\"debug\", \"Finished Message Sending\"); delay(2500); }","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#data-producer-2","text":"","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#components","text":"ESP-01 I2C bus Accelerometer LCD display","title":"Components"},{"location":"dataproducer-2/dataproducer-2/#flux","text":"","title":"Flux"},{"location":"dataproducer-2/dataproducer-2/#wiring","text":"","title":"Wiring"},{"location":"dataproducer-2/dataproducer-2/#examples-that-is-based-the-code","text":"Broker publisher example LED I2C display example Accelerometer example","title":"Examples that is based the code"},{"location":"dataproducer-2/dataproducer-2/#wires","text":"","title":"Wires"},{"location":"dataproducer-2/dataproducer-2/#code","text":"#include <LiquidCrystal_I2C.h> /* Dataproducer 2 * * */ #include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> #include <Wire.h> // libreria de comunicacion por I2C #include <ESP8266WiFi.h> #include <PubSubClient.h> const char* ssid = \"ssid\"; const char* password = \"password\"; const char* mqtt_server = \"192.168.4.1\"; WiFiClient espClient; PubSubClient client(espClient); unsigned long lastMsg = 0; #define MSG_BUFFER_SIZE (50) char msg[MSG_BUFFER_SIZE]; Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); LiquidCrystal_I2C lcd(0x27, 16, 2); // DIR, E, RW, RS, D4, D5, D6, D7 void setup_wifi() { delay(10); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); } randomSeed(micros()); } void reconnect() { // Loop until we're reconnected while (!client.connected()) { // Create a random client ID String clientId = \"ESP8266Client-\"; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str())) { client.publish(\"debug\",\"connected\"); client.publish(\"outTopic\", \"hello world\"); } else { // Wait 5 seconds before retrying delay(5000); } } } void setup() { Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server, 1883); client.publish(\"debug\", \"Setting LCD communication\"); lcd.setBacklight(HIGH); // habilita iluminacion posterior de LCD lcd.begin(0, 2); // 16 columnas por 2 lineas para LCD 1602A lcd.clear(); // limpia pantalla if (!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ client.publish(\"debug\", \"Ooops, no ADXL345 detected ... Check your wiring!\"); while (1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { if (!client.connected()) { reconnect(); } client.loop(); sensors_event_t event; accel.getEvent(&event); client.publish(\"debug\", \"Displaying information at LCD SCReen: \"); lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"X:\"); lcd.print(event.acceleration.x); lcd.print(\" Y:\"); lcd.print(event.acceleration.y);// escribe el texto lcd.setCursor(0, 1); lcd.print(\"Z: \"); lcd.print(event.acceleration.z);// ubica cursor en columna 0 y linea 1 unsigned long now = millis(); if (now - lastMsg > 2000) { sprintf(msg, \"{\\\"X\\\":%f,\\\"Y\\\":%f,\\\"Z\\\":%f}\", event.acceleration.x, event.acceleration.y, event.acceleration.z); client.publish(\"debug\", \"Published message\"); client.publish(\"debug\",\"Publish message: \"); client.publish(\"debug\",msg); client.publish(\"windmill/dataproducer2\", msg); } client.publish(\"debug\", \"Finished Message Sending\"); delay(2500); }","title":"Code"},{"location":"dataproducer-2/liquidcrystali2c/","text":"Liquid Crystal Display connected with i2c bus In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it. Instalation for arduino You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE. Example #include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); } Problems with arduino and ESP01 The library seemed to hardcode the pins that would be used for communication. For this reason, ESP01, as it had different pins, didn't work at all when using the library. Luckly for us, there was a library that already solved this . But the library itself had a weird bug for arduinos. As it seems, it's been a while since some library had a bug when printing strings: they ignored the code of the error returned by the write operation. In this case, it should return the number of bytes written, but instead, it returned always 0. For this reason, we needed to modify the library. The library with the change can be found and downloaded from quimpm/LiquidCrystal_I2C . Wiring with fritzing","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#liquid-crystal-display-connected-with-i2c-bus","text":"In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it.","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#instalation-for-arduino","text":"You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE.","title":"Instalation for arduino"},{"location":"dataproducer-2/liquidcrystali2c/#example","text":"#include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); }","title":"Example"},{"location":"dataproducer-2/liquidcrystali2c/#problems-with-arduino-and-esp01","text":"The library seemed to hardcode the pins that would be used for communication. For this reason, ESP01, as it had different pins, didn't work at all when using the library. Luckly for us, there was a library that already solved this . But the library itself had a weird bug for arduinos. As it seems, it's been a while since some library had a bug when printing strings: they ignored the code of the error returned by the write operation. In this case, it should return the number of bytes written, but instead, it returned always 0. For this reason, we needed to modify the library. The library with the change can be found and downloaded from quimpm/LiquidCrystal_I2C .","title":"Problems with arduino and ESP01"},{"location":"dataproducer-2/liquidcrystali2c/#wiring-with-fritzing","text":"","title":"Wiring with fritzing"},{"location":"esp-01/getting-started/","text":"Getting Started This file how to program in ESP-01. Configure Arduino IDE Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266! Connect USB device to ESP01 The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Getting started with ESP01"},{"location":"esp-01/getting-started/#getting-started","text":"This file how to program in ESP-01.","title":"Getting Started"},{"location":"esp-01/getting-started/#configure-arduino-ide","text":"Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266!","title":"Configure Arduino IDE"},{"location":"esp-01/getting-started/#connect-usb-device-to-esp01","text":"The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Connect USB device to ESP01"},{"location":"mqtt/broker/","text":"Getting started with uMQTTBroker We based the broker for our project as the example given by the professor. We have the libraries used by them at the libraries folder. Regard the Example The example was slightly modified. It usually returned just a counter, and printed by terminal the number of clients. As we had our NodeMCU connected directly to a source of electricity and not a computer for developing both dataproducers, we modified it so instead of printing the counter, it just prints the number of clients. Also, we used a channel for debugging purposes, and both ESP01 send the data to debug at this channels, which makes it easier to know what is happening at them at all times. Code /* uMQTTBroker demo for Arduino Minimal Demo: the program simply starts a broker and waits for any client to connect. */ #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" uMQTTBroker myBroker; /* Your WiFi config here */ char ssid[] = \"ssid\"; // your network SSID (name) char pass[] = \"password\"; // your network password int counter = 0; void setup() { Serial.begin(115200); Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); } char str[80]; void loop() { sprintf(str, \"Clients: %d\", myBroker.getClientCount()); myBroker.publish(\"broker/clients\", str); // wait a second delay(1000); }","title":"Example"},{"location":"mqtt/broker/#getting-started-with-umqttbroker","text":"We based the broker for our project as the example given by the professor. We have the libraries used by them at the libraries folder.","title":"Getting started with uMQTTBroker"},{"location":"mqtt/broker/#regard-the-example","text":"The example was slightly modified. It usually returned just a counter, and printed by terminal the number of clients. As we had our NodeMCU connected directly to a source of electricity and not a computer for developing both dataproducers, we modified it so instead of printing the counter, it just prints the number of clients. Also, we used a channel for debugging purposes, and both ESP01 send the data to debug at this channels, which makes it easier to know what is happening at them at all times.","title":"Regard the Example"},{"location":"mqtt/broker/#code","text":"/* uMQTTBroker demo for Arduino Minimal Demo: the program simply starts a broker and waits for any client to connect. */ #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" uMQTTBroker myBroker; /* Your WiFi config here */ char ssid[] = \"ssid\"; // your network SSID (name) char pass[] = \"password\"; // your network password int counter = 0; void setup() { Serial.begin(115200); Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); } char str[80]; void loop() { sprintf(str, \"Clients: %d\", myBroker.getClientCount()); myBroker.publish(\"broker/clients\", str); // wait a second delay(1000); }","title":"Code"},{"location":"mqtt/mcp/","text":"MCP23027 The MCP was quite easy to develop, but the cable management was hard. We would advise to follow a schematic and doing it calmly. Wires Code We used tried some libraries to work with the MCP23027, as using adafruit MCP23027, but it didn't seem to work for us. At the end, we used Wire and the plain protocol. /** * MQTT NodeMCU */ #include \"Wire.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); // Start the broker Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } int clients = 0; void loop() { int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); clients = (clients + 1) % NUMBER_OF_LEDS; }","title":"MCP23027"},{"location":"mqtt/mcp/#mcp23027","text":"The MCP was quite easy to develop, but the cable management was hard. We would advise to follow a schematic and doing it calmly.","title":"MCP23027"},{"location":"mqtt/mcp/#wires","text":"","title":"Wires"},{"location":"mqtt/mcp/#code","text":"We used tried some libraries to work with the MCP23027, as using adafruit MCP23027, but it didn't seem to work for us. At the end, we used Wire and the plain protocol. /** * MQTT NodeMCU */ #include \"Wire.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); // Start the broker Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } int clients = 0; void loop() { int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); clients = (clients + 1) % NUMBER_OF_LEDS; }","title":"Code"},{"location":"mqtt/mqtt/","text":"MQTT Broker Weird problems that were encountered Some USB cables didn't work at all to write the program in the nodeMCU. It was a lost of time to understand why did that happen, and, in the end, we had to buy some cables to go around it. An Arduino forum commented that most USB cables are no thought for data transfering but just for charging a mobile battery. In those cases, the cable has only two wires inside, but in the data transfering cables, it usually has 4. For mobiles and similar devices, it only affects that the data trasference is slower, but NodeMCU is not able to use 2 wires only, and needs to have the 4 of them. Components NodeMCU module I2C bus MCP23017 Segment LED bar Flux Code /** * MQTT NodeMCU */ #include \"Wire.h\" #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; uMQTTBroker myBroker; /* Your WiFi config here */ const char ssid[] = \"ssid\"; // your network SSID (name) const char pass[] = \"password\"; // your network password int counter = 0; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } void loop() { char str[80]; int clients = myBroker.getClientCount(); sprintf(str, \"Clients: %d\", clients); myBroker.publish(\"broker/clients\", str); // wait a second int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); } Wires","title":"MQTT Broker"},{"location":"mqtt/mqtt/#mqtt-broker","text":"","title":"MQTT Broker"},{"location":"mqtt/mqtt/#weird-problems-that-were-encountered","text":"Some USB cables didn't work at all to write the program in the nodeMCU. It was a lost of time to understand why did that happen, and, in the end, we had to buy some cables to go around it. An Arduino forum commented that most USB cables are no thought for data transfering but just for charging a mobile battery. In those cases, the cable has only two wires inside, but in the data transfering cables, it usually has 4. For mobiles and similar devices, it only affects that the data trasference is slower, but NodeMCU is not able to use 2 wires only, and needs to have the 4 of them.","title":"Weird problems that were encountered"},{"location":"mqtt/mqtt/#components","text":"NodeMCU module I2C bus MCP23017 Segment LED bar","title":"Components"},{"location":"mqtt/mqtt/#flux","text":"","title":"Flux"},{"location":"mqtt/mqtt/#code","text":"/** * MQTT NodeMCU */ #include \"Wire.h\" #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; uMQTTBroker myBroker; /* Your WiFi config here */ const char ssid[] = \"ssid\"; // your network SSID (name) const char pass[] = \"password\"; // your network password int counter = 0; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } void loop() { char str[80]; int clients = myBroker.getClientCount(); sprintf(str, \"Clients: %d\", clients); myBroker.publish(\"broker/clients\", str); // wait a second int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); }","title":"Code"},{"location":"mqtt/mqtt/#wires","text":"","title":"Wires"}]}