{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wind Farm Project Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Publish this to Github Pages mkdocs gh-deploy will publish whatever the branch you are currently working on. It will probably be cool to have a GitHub action. Github Repository The link to the Github Repository can be found here . Github Project The link to the Github SCRUM Project can be found here . Slides done in the subject Sprint 1 Sprint 2 Sprint 3","title":"Wind Farm Project"},{"location":"#wind-farm-project","text":"","title":"Wind Farm Project"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#publish-this-to-github-pages","text":"mkdocs gh-deploy will publish whatever the branch you are currently working on. It will probably be cool to have a GitHub action.","title":"Publish this to Github Pages"},{"location":"#github-repository","text":"The link to the Github Repository can be found here .","title":"Github Repository"},{"location":"#github-project","text":"The link to the Github SCRUM Project can be found here .","title":"Github Project"},{"location":"#slides-done-in-the-subject","text":"Sprint 1 Sprint 2 Sprint 3","title":"Slides done in the subject"},{"location":"Supervision-Station/Supervision-Station/","text":"Supervision In the image below is shown the prototype proposal of the Supervision station . Requirements The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker. User story Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station. As the last 24 hours is hard to debug, it is shown instead the last 24 values in the code. To change this, make the delay of requesting the data for an hour or compute the median for it. The schema Sequence diagram It shall be described the sequence diagrams used in the supervision station. ChibiOS and Arduino communication Arduino and ESP01 communication ChibiOS In order to find more information of ChibiOS, go here .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#supervision","text":"In the image below is shown the prototype proposal of the Supervision station .","title":"Supervision"},{"location":"Supervision-Station/Supervision-Station/#requirements","text":"The Supervision station has these requirements: There is just only one Supervision Station for the whole WTGF. All sensors are placed far from the Supervision Station. Whole WTGF data is transferred to the Supervision Station through a MQTT broker.","title":"Requirements"},{"location":"Supervision-Station/Supervision-Station/#user-story","text":"Maintenance manager requires graphically representation of the obtained sensor data, within the last 24h, in the Supervision Station. As the last 24 hours is hard to debug, it is shown instead the last 24 values in the code. To change this, make the delay of requesting the data for an hour or compute the median for it.","title":"User story"},{"location":"Supervision-Station/Supervision-Station/#the-schema","text":"","title":"The schema"},{"location":"Supervision-Station/Supervision-Station/#sequence-diagram","text":"It shall be described the sequence diagrams used in the supervision station.","title":"Sequence diagram"},{"location":"Supervision-Station/Supervision-Station/#chibios-and-arduino-communication","text":"","title":"ChibiOS and Arduino communication"},{"location":"Supervision-Station/Supervision-Station/#arduino-and-esp01-communication","text":"","title":"Arduino and ESP01 communication"},{"location":"Supervision-Station/Supervision-Station/#chibios","text":"In order to find more information of ChibiOS, go here .","title":"ChibiOS"},{"location":"Supervision-Station/arduino/","text":"Arduino The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system. At first it will be discussed the I2C protocol implementation with an example. Then, it will be explained different approaches that we tried for the connection between ESP01 and Arduino. I2C Protocol for RPi B connection /* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: } ESP01 connection At first we tried to use AT commands, as we thought that it was easier than programming a whole protocol. But, after having some troubles to make the ESP01 work against the firmware, and having already a subscriber for the mqtt broker for the ESP01, we made a simple protocol from reading that corresponds as this: '0' -> \"test\" '1' -> dataproducer1 JSON '2' -> dataproducer2 JSON 'j' -> all the state as a JSON The options '0' and 'j' are meant to be used for debugging, and the options '1' and '2' are meant to be used by the arduino. This messages are terminated with a ';' for reasons discussed later. The arduino code The arduino has quite some troubles for parsing the data, as, sometimes, ESP01 adds some noise for the lasts characters. We think that the print library sends the entire size of the array instead of a marked '\\0' character array. For this reason, we added a peculiarity: it reads until the character ';', then it discards the rest of the buffer, as the Arduino didn't request for more characters. The example for this code is: #include <ArduinoJson.h>; char msg[512]; DynamicJsonDocument dataproducer1(256); DynamicJsonDocument dataproducer2(256); void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET DATAPRODUCER1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(dataproducer1); //GET DATAPRODUCER2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(dataproducer2); delay(2000); } Merge of both codes for Arduino Mega #include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); Serial.println(\"Sending dt1...\"); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); Serial.println(\"Sending dt2...\"); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); Serial.println(\"Sending dt1...\"); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); Serial.println(\"Sending debug\"); } void senddataproducer() { Serial.print(\"dataproducer(humidity=\"); Serial.print(dt1.humidity); Serial.print(\", temperature=\"); Serial.print(dt1.temperature); Serial.print(\", heatIndex=\"); Serial.print(dt1.heatIndex); Serial.print(\", x=\"); Serial.print(dt2.x); Serial.print(\", y=\"); Serial.print(dt2.y); Serial.print(\", z=\"); Serial.print(dt2.z); Serial.println(\");\"); if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); Serial.print(\"msg = \"); Serial.println(t); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(*dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET dataproducerJson1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); } Merge of both codes for Arduino Uno","title":"Arduino"},{"location":"Supervision-Station/arduino/#arduino","text":"The arduino is between the RPi, which is connected to the LCD Screen and the ESP01, which is the data consumer in the MQTT system. At first it will be discussed the I2C protocol implementation with an example. Then, it will be explained different approaches that we tried for the connection between ESP01 and Arduino.","title":"Arduino"},{"location":"Supervision-Station/arduino/#i2c-protocol-for-rpi-b-connection","text":"/* * SLAVE CONFIG */ #include \"Wire.h\" #define SLAVE_ADDR 0x04 uint8_t value1, value2; void receiveFunc(){ while(Wire.available()!=2); value1=(uint8_t)Wire.read(); value2=(uint8_t)Wire.read(); Serial.print(value1); Serial.print(\"x\"); Serial.print(value2); } void sendFunc(){ Serial.print(\"=\"); Serial.println((uint8_t)(value1*value2)); Wire.write((uint8_t)(value1*value2)); } void setup() { // put your setup code here, to run once: Serial.begin(9600); Wire.begin(SLAVE_ADDR); Wire.onReceive(receiveFunc); Wire.onRequest(sendFunc); } void loop() { // put your main code here, to run repeatedly: }","title":"I2C Protocol for RPi B connection"},{"location":"Supervision-Station/arduino/#esp01-connection","text":"At first we tried to use AT commands, as we thought that it was easier than programming a whole protocol. But, after having some troubles to make the ESP01 work against the firmware, and having already a subscriber for the mqtt broker for the ESP01, we made a simple protocol from reading that corresponds as this: '0' -> \"test\" '1' -> dataproducer1 JSON '2' -> dataproducer2 JSON 'j' -> all the state as a JSON The options '0' and 'j' are meant to be used for debugging, and the options '1' and '2' are meant to be used by the arduino. This messages are terminated with a ';' for reasons discussed later.","title":"ESP01 connection"},{"location":"Supervision-Station/arduino/#the-arduino-code","text":"The arduino has quite some troubles for parsing the data, as, sometimes, ESP01 adds some noise for the lasts characters. We think that the print library sends the entire size of the array instead of a marked '\\0' character array. For this reason, we added a peculiarity: it reads until the character ';', then it discards the rest of the buffer, as the Arduino didn't request for more characters. The example for this code is: #include <ArduinoJson.h>; char msg[512]; DynamicJsonDocument dataproducer1(256); DynamicJsonDocument dataproducer2(256); void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET DATAPRODUCER1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(dataproducer1); //GET DATAPRODUCER2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(dataproducer2); delay(2000); }","title":"The arduino code"},{"location":"Supervision-Station/arduino/#merge-of-both-codes-for-arduino-mega","text":"#include <ArduinoJson.h>; #include \"Wire.h\" const int ARDUINO_ADDR = 0x04; typedef struct { float humidity; float temperature; float heatIndex; } dataproducer1; typedef struct{ float x; float y; float z; } dataproducer2; dataproducer1 dt1; dataproducer2 dt2; bool sendDt1ElseDt2 = true; char msg[512]; DynamicJsonDocument dataproducerJson1(256); DynamicJsonDocument dataproducerJson2(256); void sendRealdt1() { Wire.write((byte *) &dt1, 12); Serial.println(\"Sending dt1...\"); } void sendRealdt2() { Wire.write((byte *) &dt2, 12); Serial.println(\"Sending dt2...\"); } void sendCharacter() { char c = 'a'; Wire.write((byte *)&c, sizeof(char)); Serial.println(\"Sending dt1...\"); } void sendCharacters() { char c[] = \"abcdefghijlmnopqrst\"; Wire.write((byte *) &c, 12 * sizeof(char)); Serial.println(\"Sending debug\"); } void senddataproducer() { Serial.print(\"dataproducer(humidity=\"); Serial.print(dt1.humidity); Serial.print(\", temperature=\"); Serial.print(dt1.temperature); Serial.print(\", heatIndex=\"); Serial.print(dt1.heatIndex); Serial.print(\", x=\"); Serial.print(dt2.x); Serial.print(\", y=\"); Serial.print(dt2.y); Serial.print(\", z=\"); Serial.print(dt2.z); Serial.println(\");\"); if (sendDt1ElseDt2) { sendRealdt1(); } else { sendRealdt2(); } } void changeState(int numBytes) { uint8_t t = Wire.read(); Serial.print(\"msg = \"); Serial.println(t); switch (t) { case 0x00: sendDt1ElseDt2 = true; break; case 0x01: sendDt1ElseDt2 = false; } } void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial1.begin(115200); Wire.begin(ARDUINO_ADDR); Wire.onRequest(senddataproducer); Wire.onReceive(changeState); delay(100); Serial.println(\"Start up\"); while (Serial1.available()>0){} Serial1.read(); } void readDataproducer(DynamicJsonDocument *dataproducer) { char last_char = 'a'; while(Serial1.available()<=0){} delay(100); Serial.println(\"Recived a message\"); int i = 0; while(last_char != ';'){ if (Serial1.available()>0){ msg[i] = (char)Serial1.read(); last_char = msg[i]; i = i + 1; } } msg[i-1] = '\\0'; delay(500); deserializeJson(*dataproducer, msg); Serial.println(\"Dataproducer X = \"); serializeJson(*dataproducer, Serial); Serial.println(); char c; while(Serial1.available() > 0) { Serial1.readBytes(&c, 1); } } void loop() { Serial.println(\"Stated arduino comunication\"); //GET dataproducerJson1 INFO Serial1.write(\"1\"); Serial.println(\"Sended request for dataproducer1 info\"); readDataproducer(&dataproducerJson1); dt1.humidity = dataproducerJson1[\"humidity\"]; dt1.temperature = dataproducerJson1[\"temperature\"]; dt1.heatIndex = dataproducerJson1[\"hic\"]; //GET dataproducerJson2 INFO Serial1.write(\"2\"); Serial.println(\"Sended request for dataproducer2 info\"); readDataproducer(&dataproducerJson2); dt2.x = dataproducerJson2[\"X\"]; dt2.y = dataproducerJson2[\"Y\"]; dt2.z = dataproducerJson2[\"Z\"]; delay(2000); }","title":"Merge of both codes for Arduino Mega"},{"location":"Supervision-Station/arduino/#merge-of-both-codes-for-arduino-uno","text":"","title":"Merge of both codes for Arduino Uno"},{"location":"Supervision-Station/chibios/","text":"ChibiOS Introduction Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling How works? Requirements Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Demos The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img . LCD Screen For LCD Screen, there is an example of that: #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; } Arduino I2C #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; }","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#chibios","text":"","title":"ChibiOS"},{"location":"Supervision-Station/chibios/#introduction","text":"Abstracting away timing information. This allows the structure of the application code to be simplier and smaller. Maintainability/Extensibility. Fewer dependencies between modules. Task modularity. Event-driven means improved effiency. Easier power management when idle task is detected. Flexible interrupt handling","title":"Introduction"},{"location":"Supervision-Station/chibios/#how-works","text":"","title":"How works?"},{"location":"Supervision-Station/chibios/#requirements","text":"Developer ARM Toolchain. Manual installation > developer.arm.com Package manager > sudo apt-get install gcc-arm-none-eabi. Download specific version of ChibiOS for RPi B Github repository of ChibiOS-RPi B Prepare Minimum bootable SD-Card for the Raspberry Pi B bootcode.ini - Download here start.elf - Download here It has been said that loader.bin is not necessary, so we have deleted it. In order to know if the Developer ARM Toolchain is correctly working: arm-none-eabi-gcc --version Expected output: arm-none-eabi-gcc (15:9-2019-q4-0ubuntu2) 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.","title":"Requirements"},{"location":"Supervision-Station/chibios/#demos","text":"The different demos can be downloaded from here . You will have to be in ChibiOS-RPI/demos/<name_demo> . The directory should have this structure - build/ - ch.bin - ... - chconf.h - halconf.h - main.c - Makefile - mcuconf.h - readme.txt In order to build the binary you must open the terminal and type make . Then, in build/ directory, it must have been created a ch.bin file. Put the file on the SD card and rename it into kernel.img .","title":"Demos"},{"location":"Supervision-Station/chibios/#lcd-screen","text":"For LCD Screen, there is an example of that: #include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static WORKING_AREA(waThread_LCD, 128); static msg_t Thread_LCD(void *p) { (void)p; chRegSetThreadName(\"SerialPrint\"); uint16_t iteration=0; while (TRUE) { sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x10); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Iter.: %u\", iteration); iteration++; chThdSleepMilliseconds(2000); } return 0; } /* * Application entry point. */ int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); // First Message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 1:\"); // Coordinates sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x18); sdPut(&SD1, (uint8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (uint8_t)0x7C); sdPut(&SD1, (uint8_t)0x19); sdPut(&SD1, (uint8_t)0x20); chThdSleepMilliseconds(10); // Second message chprintf((BaseSequentialStream *)&SD1, \"Data consumer 2\"); // Start thread chThdCreateStatic(waThread_LCD, sizeof(waThread_LCD), HIGHPRIO, Thread_LCD, NULL); /* * Events servicing loop. */ chThdWait(chThdSelf()); return 0; }","title":"LCD Screen"},{"location":"Supervision-Station/chibios/#arduino-i2c","text":"#include \"ch.h\" #include \"hal.h\" #include \"chprintf.h\" static const uint8_t slave_address = 0x04; static WORKING_AREA(waThread_I2C, 128); static msg_t Thread_I2C(void *p) { (void)p; chRegSetThreadName(\"SerialPrintI2C\"); uint8_t request[]={0,0}; uint8_t result=0; msg_t status; // Some time to allow slaves initialization chThdSleepMilliseconds(2000); while (TRUE) { // Request values i2cMasterTransmitTimeout( &I2C0, slave_address, request, 2, &result, 1, MS2ST(1000)); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x18); sdPut(&SD1, (int8_t)0x00); chThdSleepMilliseconds(10); sdPut(&SD1, (int8_t)0x7C); sdPut(&SD1, (int8_t)0x19); sdPut(&SD1, (int8_t)0x20); chThdSleepMilliseconds(10); chprintf((BaseSequentialStream *)&SD1, \"Aval. %ux%u: %u \", request[0],request[1], result); request[1]++; if (request[1]>10) { request[1] = 0; request[0]++; } chThdSleepMilliseconds(2000); } return 0; } int main(void) { halInit(); chSysInit(); // Initialize Serial Port sdStart(&SD1, NULL); /* * I2C initialization. */ I2CConfig i2cConfig; i2cStart(&I2C0, &i2cConfig); chThdCreateStatic(waThread_I2C, sizeof(waThread_I2C), HIGHPRIO, Thread_I2C, NULL); // Blocks until finish chThdWait(chThdSelf()); return 0; }","title":"Arduino I2C"},{"location":"chibi/i2c/","text":"ChibiOS and requesting information on I2C ChibiOS has a function to request the information on I2C bus, and in this document it shall be described how it works. The function The function in question is: void i2cMasterTransmitTimeout( &I2C0, // I2C bus // the address that you are requesting information arduino_address, NULL,// the request information 0, // size sended in the request information (uint8_t *)&data, // data received sizeof(sensor_data_t), // size of the data received MS2ST(1000) // I don't really know anything about this );","title":"ChibiOS and requesting information on I2C"},{"location":"chibi/i2c/#chibios-and-requesting-information-on-i2c","text":"ChibiOS has a function to request the information on I2C bus, and in this document it shall be described how it works.","title":"ChibiOS and requesting information on I2C"},{"location":"chibi/i2c/#the-function","text":"The function in question is: void i2cMasterTransmitTimeout( &I2C0, // I2C bus // the address that you are requesting information arduino_address, NULL,// the request information 0, // size sended in the request information (uint8_t *)&data, // data received sizeof(sensor_data_t), // size of the data received MS2ST(1000) // I don't really know anything about this );","title":"The function"},{"location":"dataproducer-1/dataproducer-1/","text":"Dataproducer 1 Components Temperature and humidity sensor LCD screen ESP-01 Flux Wiring Bugs encountered We put a cable in a pin on the breadboard that didn't work at all. We spend a couple of hours debugging it.","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#dataproducer-1","text":"","title":"Dataproducer 1"},{"location":"dataproducer-1/dataproducer-1/#components","text":"Temperature and humidity sensor LCD screen ESP-01","title":"Components"},{"location":"dataproducer-1/dataproducer-1/#flux","text":"","title":"Flux"},{"location":"dataproducer-1/dataproducer-1/#wiring","text":"","title":"Wiring"},{"location":"dataproducer-1/dataproducer-1/#bugs-encountered","text":"We put a cable in a pin on the breadboard that didn't work at all. We spend a couple of hours debugging it.","title":"Bugs encountered"},{"location":"dataproducer-1/dht11/","text":"Humidity Sensor DH11 How it works How to connect to ESP-01 How to program it The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#humidity-sensor-dh11","text":"","title":"Humidity Sensor DH11"},{"location":"dataproducer-1/dht11/#how-it-works","text":"","title":"How it works"},{"location":"dataproducer-1/dht11/#how-to-connect-to-esp-01","text":"","title":"How to connect to ESP-01"},{"location":"dataproducer-1/dht11/#how-to-program-it","text":"The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"How to program it"},{"location":"dataproducer-1/graphical-lcd-backpack/","text":"Graphical LCD Backpack This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer. Connexions Example #include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#graphical-lcd-backpack","text":"This component has a library to perform some its funcionality, but it has a worse API than calling the serial backbones. For example, the library calls directly in most of the endpoints to the same serial method: void LCD::printStr(char Str[78])//26 characters is the length of one line on the LCD { serial.print(Str); //if you need to print longer strings, change the size of this array here and in the .h file } //------------------------------------------------------------------------------------------- void LCD::printNum(int num)//can't convert ints to strings so this is just for printing ints { serial.print(num); } //------------------------------------------------------------------------------------------- void LCD::nextLine()//prints new line { serial.println(); } And the method nextLine doesn't even work, as the board doesn't support \"\\n\". Instead, our program was base on the libarary to get the operations and used serial to program it better. Finally, this example was made for an arduino mega, as it supports more than one serial so that the program could be debuged in the computer.","title":"Graphical LCD Backpack"},{"location":"dataproducer-1/graphical-lcd-backpack/#connexions","text":"","title":"Connexions"},{"location":"dataproducer-1/graphical-lcd-backpack/#example","text":"#include \"DHT.h\" #define maxX 127//159 #define maxY 63 //127 DHT dht(22, DHT11); /* OUR FUNCTIONS */ void setX(byte posX) //0-127 or 0-159 pixels { //Set the X position Serial1.write(0x7C); Serial1.write(0x18);//CTRL x Serial1.write(posX); } //------------------------------------------------------------------------------------------- void clearScreen() { //clears the screen, you will use this a lot! Serial1.write(0x7C); Serial1.write((byte)0); //CTRL @ //can't send LCD.write(0) or LCD.write(0x00) because it's interprestted as a NULL } void setY(byte posY)//0-63 or 0-127 pixels { //Set the y position Serial1.write(0x7C); Serial1.write(0x19);//CTRL y Serial1.write(posY); } void setHome() { setX((byte)0); setY((byte)0); } void setup() { dht.begin(); Serial1.begin(115200); delay(1200); clearScreen(); setHome();//set the cursor back to 0,0. delay(10); Serial1.print(\"Starting dataproducer1\"); delay(1000); } void tempAndHumidity(float tempC, float humidity, float heatIndex) { //This function shows how you could read the data from a temerature and humidity //sensor and then print that data to the Graphic LCD. clearScreen(); //these could be varaibles instead of static numbers Serial1.print(\"Temperature = \"); Serial1.print(tempC); Serial1.print(\"C \"); Serial1.print(\"Humidity = \"); Serial1.print(humidity); Serial1.print(\"% \"); Serial1.print(\"Heat index = \"); Serial1.print(heatIndex); Serial1.print(\"C \"); } void loop() { // put your main code here, to run repeatedly: // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); if (isnan(h) || isnan(t)) { Serial.println(F(\"Failed to read from DHT sensor!\")); } else { float hic = dht.computeHeatIndex(t, h, false); tempAndHumidity(t, h, hic); } // Compute heat index in Celsius (isFahreheit = false) delay(2500); }","title":"Example"},{"location":"dataproducer-2/accelerometer/","text":"Accelerometer In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example. Instalation To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor. Initialization Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width } Example #include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#accelerometer","text":"In this document, the accelerometer \"ADXL345\" will be discussed. At first it will be discussed the libraries necessary for programming it. The document will continue with the initialization and it will conclude with an example.","title":"Accelerometer"},{"location":"dataproducer-2/accelerometer/#instalation","text":"To install, please install the libraries Adafruit ADXL345 and Adafruit Unified Sensor in the library gestor.","title":"Instalation"},{"location":"dataproducer-2/accelerometer/#initialization","text":"Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { if(!accel.begin()) // needed for detecting the ADXL345 at the i2c { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\"); while(1) delay(100); } accel.setRange(ADXL345_RANGE_16_G); // sets the communication width }","title":"Initialization"},{"location":"dataproducer-2/accelerometer/#example","text":"#include <Adafruit_Sensor.h> #include <Adafruit_ADXL345_U.h> Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345); void setup() { Serial.begin(9600); Serial.println(\"Initializating sensor\"); if(!accel.begin()) { /* There was a problem detecting the ADXL345 ... check your connections */ Serial.println( \"Ooops, no ADXL345 detected ... Check your wiring!\" ); while(1); } accel.setRange(ADXL345_RANGE_16_G); } void loop() { Serial.println(\"============= Processing event =============\"); sensors_event_t event; accel.getEvent(&event); Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\" \"); Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\" \"); Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\" \");Serial.println(\"m/s^2 \"); delay(500); }","title":"Example"},{"location":"dataproducer-2/dataproducer-2/","text":"Data producer 2 Components ESP-01 I2C bus Accelerometer LCD display Flux Examples that is based the code Broker publisher example LED I2C display example Accelerometer example","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#data-producer-2","text":"","title":"Data producer 2"},{"location":"dataproducer-2/dataproducer-2/#components","text":"ESP-01 I2C bus Accelerometer LCD display","title":"Components"},{"location":"dataproducer-2/dataproducer-2/#flux","text":"","title":"Flux"},{"location":"dataproducer-2/dataproducer-2/#examples-that-is-based-the-code","text":"Broker publisher example LED I2C display example Accelerometer example","title":"Examples that is based the code"},{"location":"dataproducer-2/liquidcrystali2c/","text":"Liquid Crystal Display connected with i2c bus In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it. Instalation for arduino You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE. Example #include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); } Problems with arduino and ESP01 The library seemed to hardcode the pins that would be used for communication. For this reason, ESP01, as it had different pins, didn't work at all when using the library. Luckly for us, there was a library that already solved this . But the library itself had a weird bug for arduinos. As it seems, it's been a while since some library had a bug when printing strings: they ignored the code of the error returned by the write operation. In this case, it should return the number of bytes written, but instead, it returned always 0. For this reason, we needed to modify the library. The library with the change can be found and downloaded from quimpm/LiquidCrystal_I2C . Wiring with fritzing","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#liquid-crystal-display-connected-with-i2c-bus","text":"In this document, it will be described the LCD used in the dataproducer 2. First, it will be discussed the libraries used in the application and how to install them. Secondly it will be detailed an example about how to use it.","title":"Liquid Crystal Display connected with i2c bus"},{"location":"dataproducer-2/liquidcrystali2c/#instalation-for-arduino","text":"You should download a zip containing this repository , as it is not on the library manager. Then you can install a zip using the IDE.","title":"Instalation for arduino"},{"location":"dataproducer-2/liquidcrystali2c/#example","text":"#include <Wire.h> // libreria de comunicacion por I2C #include <LCD.h> // libreria para funciones de LCD #include <LiquidCrystal_I2C.h> // libreria para LCD por I2C LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7); // Direction acces of iic, E, RW, RS, D4, D5, D6, D7 // pins respectively void setup() { Serial.begin(9600); lcd.setBacklightPin(3, POSITIVE); // pin P3 at PCF8574 as positive lcd.setBacklight(HIGH); // sets so the display shows information lcd.begin(16, 2); lcd.clear(); // cleans the display } void loop() { lcd.setCursor(0, 0); // ubica cursor en columna 0 y linea 0 lcd.print(\"Hello world!\"); lcd.setCursor(0, 1); lcd.print(milis() / 1000); lcd.print(\" seg\");// ubica cursor en columna 0 y linea 1 delay(500); }","title":"Example"},{"location":"dataproducer-2/liquidcrystali2c/#problems-with-arduino-and-esp01","text":"The library seemed to hardcode the pins that would be used for communication. For this reason, ESP01, as it had different pins, didn't work at all when using the library. Luckly for us, there was a library that already solved this . But the library itself had a weird bug for arduinos. As it seems, it's been a while since some library had a bug when printing strings: they ignored the code of the error returned by the write operation. In this case, it should return the number of bytes written, but instead, it returned always 0. For this reason, we needed to modify the library. The library with the change can be found and downloaded from quimpm/LiquidCrystal_I2C .","title":"Problems with arduino and ESP01"},{"location":"dataproducer-2/liquidcrystali2c/#wiring-with-fritzing","text":"","title":"Wiring with fritzing"},{"location":"esp-01/dh11/","text":"Humidity Sensor DH11 How it works How to connect to ESP-01 How to program it The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"Humidity Sensor DH11"},{"location":"esp-01/dh11/#humidity-sensor-dh11","text":"","title":"Humidity Sensor DH11"},{"location":"esp-01/dh11/#how-it-works","text":"","title":"How it works"},{"location":"esp-01/dh11/#how-to-connect-to-esp-01","text":"","title":"How to connect to ESP-01"},{"location":"esp-01/dh11/#how-to-program-it","text":"The following code can be found at dh11.cpp . #include <dht11.h> dht11 DHT; // Pin 4 of Arduino to Data of DHT11 #define DHT11_PIN 4 void setup() { Serial.begin(9600); int check; Serial.print(\u201cDHT11 STATUS \u2013 \\t\u201d); check = DHT.read(DHT11_PIN); // check status switch (check) { case DHTLIB_OK: Serial.print(\u201cOK\\n\u201d); break; case DHTLIB_ERROR_CHECKSUM: Serial.print(\u201cChecksum error \\n\u201d); break; case DHTLIB_ERROR_TIMEOUT: Serial.print(\u201cTimeout error \\n\u201d); break; default: Serial.print(\u201cUnknown error \\n\u201d); break; } } void loop() { // humidity and temperature output Serial.print(\u201cHumidity is \u201c); Serial.print(DHT.humidity, 1); Serial.print(\u201c\\n\u201d); Serial.println(\u201cTemperature is \u201c); Serial.println(DHT.temperature, 1); delay(1000); }","title":"How to program it"},{"location":"esp-01/getting-started/","text":"Getting Started This file how to program in ESP-01. Configure Arduino IDE Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266! Connect USB device to ESP01 The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Getting Started"},{"location":"esp-01/getting-started/#getting-started","text":"This file how to program in ESP-01.","title":"Getting Started"},{"location":"esp-01/getting-started/#configure-arduino-ide","text":"Click Ctrl+, to open the configuration. Paste https://arduino.esp8266.com/stable/package_esp8266com_index.json into Additional Boards Manager URLs. Then, at Tools > Boards > Boards manager you can download the board. Don't forget to put the board as aa esp8266!","title":"Configure Arduino IDE"},{"location":"esp-01/getting-started/#connect-usb-device-to-esp01","text":"The correct orientation of ESP is: The switch button defines the state of the connection. Developer mode to compile and put the code into the ESP01. Supplier mode. The usb provides the energy to the ESP01. Arduino IDE configuration for ESP1: - Builtin Led: \"1\"","title":"Connect USB device to ESP01"},{"location":"esp-01/lcd/","text":"LCD Screen DataSheets Technical Docs Code Library: SparkFun Graphic LCD Serial Backpack Example code: here How works You give the information of the pointer to start writing and, then, give the string. Configuration of the board The Rx of the LCD must be the Tx of the board and the other way around.","title":"LCD Screen"},{"location":"esp-01/lcd/#lcd-screen","text":"DataSheets Technical Docs","title":"LCD Screen"},{"location":"esp-01/lcd/#code","text":"Library: SparkFun Graphic LCD Serial Backpack Example code: here","title":"Code"},{"location":"esp-01/lcd/#how-works","text":"You give the information of the pointer to start writing and, then, give the string.","title":"How works"},{"location":"esp-01/lcd/#configuration-of-the-board","text":"The Rx of the LCD must be the Tx of the board and the other way around.","title":"Configuration of the board"},{"location":"mqtt/broker/","text":"Broker We based the broker for our project as the example given by the professor. We have the libraries used by them at the libraries folder. Regard the Example The example was slightly modified. It usually returned just a counter, and printed by terminal the number of clients. As we had our NodeMCU connected directly to a source of electricity and not a computer for developing both dataproducers, we modified it so instead of printing the counter, it just prints the number of clients. Also, we used a channel for debugging purposes, and both ESP01 send the data to debug at this channels, which makes it easier to know what is happening at them at all times. Code /* uMQTTBroker demo for Arduino Minimal Demo: the program simply starts a broker and waits for any client to connect. */ #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" uMQTTBroker myBroker; /* Your WiFi config here */ char ssid[] = \"ssid\"; // your network SSID (name) char pass[] = \"password\"; // your network password int counter = 0; void setup() { Serial.begin(115200); Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); } char str[80]; void loop() { sprintf(str, \"Clients: %d\", myBroker.getClientCount()); myBroker.publish(\"broker/clients\", str); // wait a second delay(1000); }","title":"Broker"},{"location":"mqtt/broker/#broker","text":"We based the broker for our project as the example given by the professor. We have the libraries used by them at the libraries folder.","title":"Broker"},{"location":"mqtt/broker/#regard-the-example","text":"The example was slightly modified. It usually returned just a counter, and printed by terminal the number of clients. As we had our NodeMCU connected directly to a source of electricity and not a computer for developing both dataproducers, we modified it so instead of printing the counter, it just prints the number of clients. Also, we used a channel for debugging purposes, and both ESP01 send the data to debug at this channels, which makes it easier to know what is happening at them at all times.","title":"Regard the Example"},{"location":"mqtt/broker/#code","text":"/* uMQTTBroker demo for Arduino Minimal Demo: the program simply starts a broker and waits for any client to connect. */ #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" uMQTTBroker myBroker; /* Your WiFi config here */ char ssid[] = \"ssid\"; // your network SSID (name) char pass[] = \"password\"; // your network password int counter = 0; void setup() { Serial.begin(115200); Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); } char str[80]; void loop() { sprintf(str, \"Clients: %d\", myBroker.getClientCount()); myBroker.publish(\"broker/clients\", str); // wait a second delay(1000); }","title":"Code"},{"location":"mqtt/mcp/","text":"MCP23027 The MCP was quite easy to develop, but the cable management was hard. We would advise to follow a schematic and doing it calmly. Wires Code We used tried some libraries to work with the MCP23027, as using adafruit MCP23027, but it didn't seem to work for us. At the end, we used Wire and the plain protocol. /** * MQTT NodeMCU */ #include \"Wire.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); // Start the broker Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } int clients = 0; void loop() { int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); clients = (clients + 1) % NUMBER_OF_LEDS; }","title":"MCP23027"},{"location":"mqtt/mcp/#mcp23027","text":"The MCP was quite easy to develop, but the cable management was hard. We would advise to follow a schematic and doing it calmly.","title":"MCP23027"},{"location":"mqtt/mcp/#wires","text":"","title":"Wires"},{"location":"mqtt/mcp/#code","text":"We used tried some libraries to work with the MCP23027, as using adafruit MCP23027, but it didn't seem to work for us. At the end, we used Wire and the plain protocol. /** * MQTT NodeMCU */ #include \"Wire.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); // Start the broker Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } int clients = 0; void loop() { int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); clients = (clients + 1) % NUMBER_OF_LEDS; }","title":"Code"},{"location":"mqtt/mqtt/","text":"MQTT Broker Weird problems that be encountered Some USB cables didn't work at all to write the program in the nodeMCU. It was a lost of time to understand why did that happen, and, in the end, we had to buy some cables to go around it. An Arduino forum commented that most USB cables are no thought for data transfering but just for charging a mobile battery. In those cases, the cable has only two wires inside, but in the data transfering cables, it usually has 4. For mobiles and similar devices, it only affects that the data trasference is slower, but NodeMCU is not able to use 2 wires only, and needs to have the 4 of them. Components NodeMCU module I2C bus MCP23017 Segment LED bar Flux Code /** * MQTT NodeMCU */ #include \"Wire.h\" #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; uMQTTBroker myBroker; /* Your WiFi config here */ const char ssid[] = \"ssid\"; // your network SSID (name) const char pass[] = \"password\"; // your network password int counter = 0; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } void loop() { char str[80]; int clients = myBroker.getClientCount(); sprintf(str, \"Clients: %d\", clients); myBroker.publish(\"broker/clients\", str); // wait a second int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); } Wires","title":"MQTT Broker"},{"location":"mqtt/mqtt/#mqtt-broker","text":"","title":"MQTT Broker"},{"location":"mqtt/mqtt/#weird-problems-that-be-encountered","text":"Some USB cables didn't work at all to write the program in the nodeMCU. It was a lost of time to understand why did that happen, and, in the end, we had to buy some cables to go around it. An Arduino forum commented that most USB cables are no thought for data transfering but just for charging a mobile battery. In those cases, the cable has only two wires inside, but in the data transfering cables, it usually has 4. For mobiles and similar devices, it only affects that the data trasference is slower, but NodeMCU is not able to use 2 wires only, and needs to have the 4 of them.","title":"Weird problems that be encountered"},{"location":"mqtt/mqtt/#components","text":"NodeMCU module I2C bus MCP23017 Segment LED bar","title":"Components"},{"location":"mqtt/mqtt/#flux","text":"","title":"Flux"},{"location":"mqtt/mqtt/#code","text":"/** * MQTT NodeMCU */ #include \"Wire.h\" #include <ESP8266WiFi.h> #include \"uMQTTBroker.h\" #define WIRE_SPEED 3400000 #define MCPADDRESS 0x20 // Conf LOW-LOW-LOW // Main registers #define IODIRA 0x00 #define IODIRB 0x01 #define IOCON 0x05 #define GPIOA 0x12 #define GPIOB 0x13 #define GPPUA 0x0C #define GPPUB 0x0D // Control #define BANK 0x80 // 0b10000000 --> 1 Different banks, 0 Same bank #define MIRROR 0x40 // 0b01000000 --> 1 Int connected, 0 Int dissociated (A/B) #define SEQOP 0x20 // 0b00100000 --> 1 SEQ, 0 DIRECT #define DISSLW 0x10 // 0b00010000 --> 1 Disabled #define HAEN 0x08 // 0b00001000 --> 1 HW , 0 Disabled #define ODR 0x04 // 0b00000100 --> 1 Open Drain #define INTPOL 0x02 // 0b00000010 --> 1 INT Active High, INT 0 Active Low const int NUMBER_OF_LEDS = 4; uMQTTBroker myBroker; /* Your WiFi config here */ const char ssid[] = \"ssid\"; // your network SSID (name) const char pass[] = \"password\"; // your network password int counter = 0; void mcpSetUp() { // MCP Configuration Wire.beginTransmission(MCPADDRESS); Wire.write(IOCON); // Sequential access - better performance Wire.write(SEQOP | MIRROR | HAEN ); Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(IODIRA); Wire.write(0xFF); // A Register INPUT Wire.write(0x00); // B Register OUTPUT Wire.endTransmission(); Wire.beginTransmission(MCPADDRESS); Wire.write(GPPUA); // PULL-UP resistors Wire.write(0xFF); // A Register Wire.write(0xFF); // B Register Wire.endTransmission(); } void setup() { Serial.begin(115200); //9600bps while (!Serial) {}; //Serial port initialization Serial.println(); Serial.println(); WiFi.softAP(ssid, pass); Serial.println(\"AP started\"); Serial.println(\"IP address: \" + WiFi.softAPIP().toString()); // Start the broker Serial.println(\"Starting MQTT broker\"); myBroker.init(); myBroker.subscribe(\"#\"); Wire.setClock(WIRE_SPEED); // I2C Bus speed Wire.begin(); // wake up I2C bus mcpSetUp(); } int toLedValue(int num) { return int(pow(2, num) - 0.5); } void writeLeds(int num) { Wire.beginTransmission(MCPADDRESS); Wire.write(GPIOB); // B Register Wire.write(num); // value to send - all HIGH Wire.endTransmission(); } void loop() { char str[80]; int clients = myBroker.getClientCount(); sprintf(str, \"Clients: %d\", clients); myBroker.publish(\"broker/clients\", str); // wait a second int ledsValue = constrain(clients, 0, NUMBER_OF_LEDS); sprintf(str, \"Set leds to: %d\", ledsValue); myBroker.publish(\"debug\", str); writeLeds(toLedValue(ledsValue)); delay(1000); }","title":"Code"},{"location":"mqtt/mqtt/#wires","text":"","title":"Wires"}]}